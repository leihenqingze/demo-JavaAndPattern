不变模式可增强对象的强壮性。不变模式允许多个对象共享某一个对象，降低了对该对象进行并发访问时的同步化开销。如果需要修改一个不变对象的状态，那么就需要建立一个新的同类型对象，并在创建时将这个新的状态存储在新对象里。

一个类的内部状态创建之后，在整个生命周期都不会发生变化时，这样的类称做不变类。

### 弱不变模式
一个类的实例的状态是不可变化的，但是这个类的子类的实例具有可能会变化的状态。

1.所考虑的对象没有任何方法会修改对象的状态：这样一来，当对象的构造器将对象的状态初始化之后，对象的状态便不再改变。

2.所有的属性都应当是私有的。不要声明任何的公开属性，以防客户端对象直接修改任何的内部状态。

3.这个对象所引用到的其他对象如果是可变对象的话，必须设法限制外界对这些可变对象的访问，以防止外界修改这些对象。如果可能，应当尽量在不变对象内部初始化这些被引用到的对象，而不要在客户端初始化，然后再传入到不变对象内部来。如果某个可变对象必须在客户端初始化，然后再传入到不变对象里的话，就应当考虑在不变对象初始化的时候，将这个可变对象复制一份，而不要使用原来的拷贝。

#### 缺点
1.一个弱不变对象的子对象可以是可变对象。

2.这个可变的子对象可能可以修改父对象的状态，从而可能会允许外界修改父对象的状态。

### 强不变模式
一个类的实例的状态不会改变：同时它的子类的实例也具有不可变化的状态。

1.所考虑的类所有的方法都应当是final，这样这个类的子类不能够置换掉此类的方法。

2.这个类本身就是final，那么这个类就不可能会有子类。


### "不变"和"只读"
当一个变量是"只读"时，变量的值不能直接改变，但是可以在其他变量发生改变的时候发生变化。

比如，一个人的出生年月是"不变"属性，而一个人的年龄便是"只读"属性。

### String 类
Java的String是一个强不变类。
如果程序所处理的文字串有频繁的内容变化时，就不宜使用String类，而应当考虑使用StringBuffer类；如果需要对文字串做大量的循环查询时，也不宜使用String类。而应当考虑使用byte或char数组。

所有的Java包装类都是强不变类。

### 优点
1.因为不能修改一个不变对象的状态，所以可以避免由此引起的不必要的程序错误。一个不变的对象要比可变的对象更加容易维护。

2.因为没有任何一个线程能修改不变对象的内部状态，一个不变对象自动就是线程安全的，这样就可以省掉处理同步化的开销，一个不变对象可以自由地被不同的客户端共享。

3.一旦需要修改一个不变对象的状态，就只好创建一个新的同类对象。在需要频繁修改不变对象的环境里，会有大量的不变对象作为中间结果被创建出来，再被Java语言的垃圾收集器收集走。这是一种资源上的浪费。

4.在设计任何一个类的时候，应当慎重考虑其状态是否有需要变化的可能性。除非其状态有变化的必要，不然应当将它设计成不变类。

### 不变模式与享元模式

享元模式以共享方式支持大量的实例。享元模式中的享元对象可以是不变对象。实际上，大多数的享元对象是不变对象。

但是，享元模式不要求享元对象是不变对象。享元模式要求享元对象状态不随环境变化而变化，这是使享元对象可以共享的条件。当然如果享元对象成为不变对象的话，是满足享元模式要求的。

享元模式对享元对象的要求是它的内蕴状态与环境无关。这就意味着如果享元对象具有某个可变的状态，但是只要不会影响享元对象的共享，也是允许的。

不变模式对不变对象的约束较强，而享元模式对享元对象的约束较弱。只要系统允许，可以使用不变模式实现享元对象，但是享元对象不一定非得是不变对象不可。

### 其他

构造方法不需要同步化，因为它只可能发生在一个线程里，在构造方法返回值前没有其他线程可以使用该对象。

一个子类可以置换掉父类的同步方法，使它同步或不同步。这就是说，子类的方法不继承其父类的方法的特性。父类的方法不改变，如果明显地调用父类的同步方法，那么这个方法将是同步调用的。